1. WhatsApp (Evolution API + opção Baileys),

2. E-mail via Gmail API com Refresh Token,

3. /metrics (Prometheus) com contadores do funil.

stack: Node 18+, npm i axios express prom-client googleapis nodemailer @adiwajshing/baileys
 env: ver cada seção. Reaproveita /shared/http.ts, /shared/db.ts, /shared/worker.ts.
________________


1) WhatsApp — Evolution API (HTTP)
Uso preferencial em produção (HTTP + chave). Mantém idempotência e pacing.
1.1 Cliente Evolution (/connectors/whatsapp/evolution.ts)
// /connectors/whatsapp/evolution.ts
import axios from "axios";
import { sleep } from "../../shared/utils";


type SendParams = {
  to_e164: string;             // +55...
  body: string;                // texto final já renderizado
  idemKey: string;             // idempotency_key do evento
  reference?: string;          // seu lead_id/trace
};


const BASE = process.env.EVOLUTION_BASE_URL!;      // ex.: https://evolution.example.com
const KEY  = process.env.EVOLUTION_API_KEY!;       // Bearer/Token
const FROM = process.env.EVOLUTION_INSTANCE_ID!;   // id da instância


export async function sendWA({ to_e164, body, idemKey, reference }: SendParams){
  // Evolution mais comum aceita rota /message/sendText (varia por vendor)
  const url = `${BASE}/message/sendText/${FROM}`;
  const headers = {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${KEY}`,
    "X-Idempotency-Key": idemKey
  };
  const payload = {
    number: to_e164.replace("+",""),
    options: { delay: 0, presence: "composing" },
    textMessage: { text: body },
    reference
  };


  for (let attempt=1; attempt<=3; attempt++){
    try {
      const { data, status } = await axios.post(url, payload, { headers, timeout: 15000 });
      return { ok: status>=200 && status<300, data };
    } catch (err:any) {
      const code = err?.response?.status || 0;
      if (code>=500 || code===429) { await sleep(500 * attempt); continue; }
      return { ok:false, error: String(err?.response?.data || err?.message || err) };
    }
  }
  return { ok:false, error: "evolution: retries_exhausted" };
}


1.2 Pacing + janela por DDD (anti-spam)
// /connectors/whatsapp/pacing.ts
export function allowedWindowNow(ddd?: string){
  // seg–sex 08:00–18:00 Fortaleza (TZ no .env)
  const now = new Date();
  const day = now.getDay();                      // 0: dom ... 6: sáb
  const hour = now.getHours();
  if (day===0 || day===6) return false;
  return hour>=8 && hour<18;
}


const CAP_POR_MINUTO = Number(process.env.WA_CAP_PER_MINUTE || 30);
let sentThisMinute = 0, windowStart = Date.now();


export function tokenBucket(){
  const now = Date.now();
  if (now - windowStart >= 60_000){ windowStart = now; sentThisMinute = 0; }
  if (sentThisMinute >= CAP_POR_MINUTO) return false;
  sentThisMinute += 1; return true;
}


1.3 Disparo WhatsApp (consumidor de mensagens_modelo)
// /agents/disparo/whatsapp.ts
import { pool } from "../../shared/db";
import { runOutbox } from "../../shared/worker";
import { sendWA } from "../../connectors/whatsapp/evolution";
import { tokenBucket, allowedWindowNow } from "../../connectors/whatsapp/pacing";
import { makeIdemKey } from "../../shared/utils";


function render(template:string, data:Record<string,any>){
  return template.replace(/{{\s*([\w.]+)\s*}}/g, (_m, k)=> String(data[k] ?? ""));
}


runOutbox("agents.disparo.whatsapp", async (payload)=>{
  // payload: { lead_id, msg_modelo_id, dataRender, contato:{telefone_e164}, trace_id }
  const { lead_id, msg_modelo_id, dataRender, contato, trace_id } = payload || {};
  if (!contato?.telefone_e164) throw new Error("no_phone");
  if (!allowedWindowNow(contato.ddd)) throw new Error("outside_window");


  // carrega template e canal
  const mm = await pool.query(`select m.template, m.canal
                                 from mensagens_modelo m
                                where m.id=$1 and m.canal='whatsapp'`,[msg_modelo_id]);
  if (mm.rowCount===0) throw new Error("template_not_found");
  const text = render(mm.rows[0].template, dataRender||{});


  // pacing
  if (!tokenBucket()) throw new Error("rate_limited_local");


  const idem = makeIdemKey("mensagem.enviada@v1", "wa", `${lead_id}:${msg_modelo_id}`);
  const res = await sendWA({
    to_e164: contato.telefone_e164,
    body: text,
    idemKey: idem,
    reference: String(trace_id||lead_id)
  });


  // log do resultado
  await pool.query(`insert into event_log(event_type,payload,idempotency_key,trace_id)
                    values ($1,$2,$3,$4)`,[
    "mensagem.enviada@v1",
    { lead_id, canal:"whatsapp", msg_modelo_id, ok: res.ok, data: res.data||res.error },
    idem, trace_id || "00000000-0000-0000-0000-000000000000"
  ]);
});


Webhook de resposta do Evolution: basta criar um endpoint POST no Agente de Atendimento e validar x-signature (se disponível). Converta para resposta.recebida@v1 (lead_id por telefone).
________________


2) WhatsApp — Baileys (opcional, local)
Útil em homologação sem provedor externo. Requer session/QR; pode ter limitações.
// /connectors/whatsapp/baileys.ts
import makeWASocket, { useMultiFileAuthState, DisconnectReason } from "@adiwajshing/baileys";
import { Boom } from "@hapi/boom";


let sockPromise: Promise<ReturnType<typeof makeWASocket>> | null = null;


export async function getBaileys(){
  if (sockPromise) return sockPromise;
  sockPromise = (async ()=>{
    const { state, saveCreds } = await useMultiFileAuthState("./.wa-session");
    const sock = makeWASocket({ auth: state, printQRInTerminal: true });
    sock.ev.on("creds.update", saveCreds);
    sock.ev.on("connection.update", (u)=>{
      const reason = (u.lastDisconnect?.error as Boom)?.output?.statusCode;
      if (u.connection === "close" && reason !== DisconnectReason.loggedOut) { getBaileys(); }
    });
    return sock;
  })();
  return sockPromise;
}


export async function sendWABaileys(jid:string, text:string){
  const sock = await getBaileys();
  await sock.sendMessage(jid, { text });
}


________________


3) Gmail — envio com Gmail API + Refresh Token
Sem SMTP. Usa OAuth2 “installed app” (ou desktop) com GMAIL_CLIENT_ID/SECRET/REFRESH_TOKEN. Endereça DKIM/SPF no domínio para reputação.
3.1 Wrapper OAuth2 + send (/connectors/email/gmail.ts)
// /connectors/email/gmail.ts
import { google } from "googleapis";


const clientId = process.env.GMAIL_CLIENT_ID!;
const clientSecret = process.env.GMAIL_CLIENT_SECRET!;
const refreshToken = process.env.GMAIL_REFRESH_TOKEN!;
const user = process.env.GMAIL_USER!; // endereço remetente verificado


function makeClient(){
  const oauth2 = new google.auth.OAuth2(clientId, clientSecret);
  oauth2.setCredentials({ refresh_token: refreshToken });
  return oauth2;
}


function buildRFC822({ from, to, subject, text, html }: any){
  const lines = [
    `From: ${from}`,
    `To: ${to}`,
    `Subject: ${subject}`,
    "MIME-Version: 1.0",
    "Content-Type: text/html; charset=UTF-8",
    "",
    html || `<pre>${text}</pre>`
  ];
  const raw = Buffer.from(lines.join("\r\n")).toString("base64url");
  return raw;
}


export async function sendGmail({ to, subject, text, html }:{
  to: string; subject: string; text?: string; html?: string;
}){
  const auth = makeClient();
  const gmail = google.gmail({ version: "v1", auth });
  const raw = buildRFC822({ from: user, to, subject, text, html });
  const res = await gmail.users.messages.send({
    userId: "me", requestBody: { raw }
  });
  return res.data;
}


3.2 Consumidor de e-mail (disparo)
// /agents/disparo/email.ts
import { pool } from "../../shared/db";
import { runOutbox } from "../../shared/worker";
import { sendGmail } from "../../connectors/email/gmail";
import { makeIdemKey } from "../../shared/utils";


function render(t:string, d:Record<string,any>){
  return t.replace(/{{\s*([\w.]+)\s*}}/g, (_m,k)=> String(d[k] ?? ""));
}


runOutbox("agents.disparo.email", async (payload)=>{
  const { lead_id, msg_modelo_id, dataRender, contato, trace_id } = payload || {};
  if (!contato?.email) throw new Error("no_email");


  const mm = await (await pool.query(
    `select template from mensagens_modelo where id=$1 and canal='email'`,[msg_modelo_id]
  ));
  if (mm.rowCount===0) throw new Error("template_not_found");


  const html = render(mm.rows[0].template, dataRender||{});
  const idem = makeIdemKey("mensagem.enviada@v1", "email", `${lead_id}:${msg_modelo_id}`);
  const data = await sendGmail({
    to: contato.email,
    subject: render("{{assunto||'Proposta de valor'}}", dataRender||{}),
    html
  });


  await pool.query(`insert into event_log(event_type,payload,idempotency_key,trace_id)
                    values ($1,$2,$3,$4)`,[
    "mensagem.enviada@v1",
    { lead_id, canal:"email", msg_modelo_id, ok:true, data },
    idem, trace_id || "00000000-0000-0000-0000-000000000000"
  ]);
});


.env (e-mail)
GMAIL_CLIENT_ID=...
GMAIL_CLIENT_SECRET=...
GMAIL_REFRESH_TOKEN=...
GMAIL_USER=contato@seu-dominio.com.br


________________


4) /metrics — Prometheus (funil + latência)
Coletor simples + contadores por evento/canal.
4.1 Registrador (/observability/metrics.ts)
// /observability/metrics.ts
import client from "prom-client";
import express from "express";


export const register = new client.Registry();
client.collectDefaultMetrics({ register });


export const cntEvento = new client.Counter({
  name: "event_total",
  help: "Eventos canônicos recebidos/emitidos",
  labelNames: ["event_type"] as const
});
export const cntDisparo = new client.Counter({
  name: "disparo_total",
  help: "Disparos por canal",
  labelNames: ["canal","status"] as const
});
export const histLat = new client.Histogram({
  name: "latency_ms",
  help: "Latência operações críticas",
  buckets: [25, 50, 100, 250, 500, 1000, 2000, 5000]
});
register.registerMetric(cntEvento);
register.registerMetric(cntDisparo);
register.registerMetric(histLat);


export function mountMetrics(app: express.Express){
  app.get("/metrics", async (_req, res)=>{
    res.setHeader("Content-Type", register.contentType);
    res.send(await register.metrics());
  });
}


4.2 Integrar no orchestrator (ou em cada agente)
// /orchestrator/index.ts
import { makeApp } from "../shared/http";
import { mountMetrics, cntEvento } from "../observability/metrics";


const app = makeApp();
mountMetrics(app);


// exemplo de emissão
app.post("/events", (req,res)=>{
  // ... valida HMAC, persiste event_log/outbox
  cntEvento.inc({ event_type: "lead.higienizado@v1" });
  res.json({ ok:true });
});


app.listen(process.env.PORT || 3000, ()=>console.log("orchestrator up"));


Dica: nos consumidores de WhatsApp/E-mail incremente cntDisparo com { canal:"whatsapp", status:"ok|fail" }. Para medir latência, envolva trechos com const end = histLat.startTimer(); ... end();.
________________


5) Conectando tudo ao funil (resumo de ligações)
   * Recebimento importa CSV/JSON → popula empresas/contatos/leads → emite lead.higienizado@v1 → outbox → agents.estrategia.

   * Estratégia grava estrategias/mensagens_modelo → (opcional) emite estrategia.campanha@v1 → outbox para agents.disparo.whatsapp / agents.disparo.email com msg_modelo_id + dataRender.

   * Disparo usa Evolution/Gmail → grava mensagem.enviada@v1 → /metrics registra contadores.

   * Atendimento (webhook WA) transforma respostas → resposta.recebida@v1 → alimenta classificação/agenda.

________________


6) Variáveis de ambiente (complemento)
# WhatsApp Evolution
EVOLUTION_BASE_URL=https://evolution.example.com
EVOLUTION_API_KEY=...
EVOLUTION_INSTANCE_ID=instance-01
WA_CAP_PER_MINUTE=30


# Gmail (API OAuth2)
GMAIL_CLIENT_ID=...
GMAIL_CLIENT_SECRET=...
GMAIL_REFRESH_TOKEN=...
GMAIL_USER=contato@seu-dominio.com.br


________________


Roteiro de smoke test
      1. /metrics retorna algo? (curl /metrics)

      2. Importar CSV no Recebimento → checar event_log/outbox.

      3. Criar manualmente um item de outbox com consumer='agents.disparo.whatsapp' + payload de teste → worker envia WA (Evolution).

      4. Mesmo teste para email.

      5. Explorar contadores no Prometheus/Grafana (se tiver).