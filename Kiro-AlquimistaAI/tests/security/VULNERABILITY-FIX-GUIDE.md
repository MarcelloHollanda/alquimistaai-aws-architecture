# Guia de Corre√ß√£o de Vulnerabilidades - Painel Operacional

Este documento fornece instru√ß√µes detalhadas para corrigir as vulnerabilidades encontradas nos testes de seguran√ßa.

---

## 1. Implementar Rate Limiting

### Severidade: üî¥ CR√çTICA

### Implementa√ß√£o no Lambda

**Arquivo**: `lambda/shared/rate-limiter.ts`

```typescript
import { DynamoDB } from 'aws-sdk';

const dynamodb = new DynamoDB.DocumentClient();
const TABLE_NAME = process.env.RATE_LIMIT_TABLE || 'rate-limits';

interface RateLimitConfig {
  maxRequests: number;
  windowSeconds: number;
}

const LIMITS: Record<string, RateLimitConfig> = {
  ip: { maxRequests: 100, windowSeconds: 60 },
  tenant: { maxRequests: 1000, windowSeconds: 60 },
  user: { maxRequests: 500, windowSeconds: 60 }
};

export async function checkRateLimit(
  key: string,
  type: 'ip' | 'tenant' | 'user'
): Promise<{ allowed: boolean; remaining: number }> {
  const config = LIMITS[type];
  const now = Math.floor(Date.now() / 1000);
  const windowStart = now - config.windowSeconds;

  try {
    // Buscar contagem atual
    const result = await dynamodb.get({
      TableName: TABLE_NAME,
      Key: { key, type }
    }).promise();

    const item = result.Item;
    
    if (!item || item.windowStart < windowStart) {
      // Nova janela ou janela expirada
      await dynamodb.put({
        TableName: TABLE_NAME,
        Item: {
          key,
          type,
          count: 1,
          windowStart: now,
          ttl: now + config.windowSeconds + 3600 // TTL com margem
        }
      }).promise();

      return {
        allowed: true,
        remaining: config.maxRequests - 1
      };
    }

    // Janela atual
    if (item.count >= config.maxRequests) {
      return {
        allowed: false,
        remaining: 0
      };
    }

    // Incrementar contador
    await dynamodb.update({
      TableName: TABLE_NAME,
      Key: { key, type },
      UpdateExpression: 'SET #count = #count + :inc',
      ExpressionAttributeNames: {
        '#count': 'count'
      },
      ExpressionAttributeValues: {
        ':inc': 1
      }
    }).promise();

    return {
      allowed: true,
      remaining: config.maxRequests - item.count - 1
    };

  } catch (error) {
    console.error('Rate limit check error:', error);
    // Em caso de erro, permitir requisi√ß√£o (fail open)
    return { allowed: true, remaining: -1 };
  }
}

export function rateLimitMiddleware(type: 'ip' | 'tenant' | 'user' = 'ip') {
  return async (event: any, next: Function) => {
    const key = type === 'ip' 
      ? event.requestContext.identity.sourceIp
      : type === 'tenant'
      ? event.requestContext.authorizer?.claims['custom:tenant_id']
      : event.requestContext.authorizer?.claims.sub;

    if (!key) {
      return next();
    }

    const result = await checkRateLimit(key, type);

    if (!result.allowed) {
      return {
        statusCode: 429,
        headers: {
          'Content-Type': 'application/json',
          'Retry-After': '60',
          'X-RateLimit-Limit': LIMITS[type].maxRequests.toString(),
          'X-RateLimit-Remaining': '0',
          'X-RateLimit-Reset': (Math.floor(Date.now() / 1000) + LIMITS[type].windowSeconds).toString()
        },
        body: JSON.stringify({
          error: 'Too Many Requests',
          message: 'Rate limit exceeded. Please try again later.'
        })
      };
    }

    // Adicionar headers de rate limit
    const response = await next();
    
    return {
      ...response,
      headers: {
        ...response.headers,
        'X-RateLimit-Limit': LIMITS[type].maxRequests.toString(),
        'X-RateLimit-Remaining': result.remaining.toString(),
        'X-RateLimit-Reset': (Math.floor(Date.now() / 1000) + LIMITS[type].windowSeconds).toString()
      }
    };
  };
}
```

### Criar Tabela DynamoDB

**Arquivo**: `lib/operational-dashboard-stack.ts`

```typescript
// Adicionar ao stack
const rateLimitTable = new dynamodb.Table(this, 'RateLimitTable', {
  tableName: `${env}-operational-dashboard-rate-limits`,
  partitionKey: { name: 'key', type: dynamodb.AttributeType.STRING },
  sortKey: { name: 'type', type: dynamodb.AttributeType.STRING },
  billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
  timeToLiveAttribute: 'ttl',
  removalPolicy: cdk.RemovalPolicy.DESTROY
});

// Conceder permiss√µes √†s Lambdas
rateLimitTable.grantReadWriteData(getTenantMeLambda);
rateLimitTable.grantReadWriteData(listTenantsLambda);
// ... outras lambdas
```

### Usar Middleware nos Handlers

```typescript
import { rateLimitMiddleware } from '../shared/rate-limiter';

export const handler = async (event: APIGatewayProxyEvent) => {
  // Aplicar rate limiting
  const rateLimitResult = await rateLimitMiddleware('ip')(event, async () => {
    // L√≥gica do handler
    return {
      statusCode: 200,
      body: JSON.stringify({ data: 'response' })
    };
  });

  return rateLimitResult;
};
```

---

## 2. Configurar Headers de Seguran√ßa

### Severidade: üü† ALTA

### Op√ß√£o 1: Configurar no API Gateway

**Arquivo**: `lib/operational-dashboard-stack.ts`

```typescript
// Adicionar response headers no API Gateway
const api = new apigateway.HttpApi(this, 'OperationalDashboardApi', {
  // ... configura√ß√µes existentes
  defaultDomainMapping: {
    domainName: apiDomain,
  },
  corsPreflight: {
    allowOrigins: [
      'https://app.alquimista.ai',
      'https://app-dev.alquimista.ai'
    ],
    allowMethods: [
      apigateway.CorsHttpMethod.GET,
      apigateway.CorsHttpMethod.POST,
      apigateway.CorsHttpMethod.PUT,
      apigateway.CorsHttpMethod.DELETE
    ],
    allowHeaders: [
      'Content-Type',
      'Authorization',
      'X-Requested-With'
    ],
    maxAge: cdk.Duration.hours(1)
  }
});

// Adicionar response mapping para headers de seguran√ßa
const integration = new apigateway.HttpLambdaIntegration('Integration', lambda, {
  payloadFormatVersion: apigateway.PayloadFormatVersion.VERSION_2_0,
  responseParameters: [
    {
      statusCode: '200',
      mappings: {
        'X-Content-Type-Options': 'nosniff',
        'X-Frame-Options': 'DENY',
        'X-XSS-Protection': '1; mode=block',
        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
        'Content-Security-Policy': "default-src 'self'"
      }
    }
  ]
});
```

### Op√ß√£o 2: Adicionar nos Lambda Responses

**Arquivo**: `lambda/shared/response-builder.ts`

```typescript
export interface ApiResponse {
  statusCode: number;
  headers?: Record<string, string>;
  body: string;
}

const SECURITY_HEADERS = {
  'X-Content-Type-Options': 'nosniff',
  'X-Frame-Options': 'DENY',
  'X-XSS-Protection': '1; mode=block',
  'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
  'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",
  'Referrer-Policy': 'strict-origin-when-cross-origin',
  'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'
};

export function buildResponse(
  statusCode: number,
  body: any,
  additionalHeaders?: Record<string, string>
): ApiResponse {
  return {
    statusCode,
    headers: {
      'Content-Type': 'application/json',
      ...SECURITY_HEADERS,
      ...additionalHeaders
    },
    body: JSON.stringify(body)
  };
}

export function successResponse(data: any): ApiResponse {
  return buildResponse(200, data);
}

export function errorResponse(statusCode: number, message: string): ApiResponse {
  return buildResponse(statusCode, { error: message });
}
```

### Usar nos Handlers

```typescript
import { successResponse, errorResponse } from '../shared/response-builder';

export const handler = async (event: APIGatewayProxyEvent) => {
  try {
    const data = await fetchData();
    return successResponse(data);
  } catch (error) {
    return errorResponse(500, 'Internal server error');
  }
};
```

---

## 3. Garantir Uso de Prepared Statements

### Severidade: üü† ALTA

### Auditoria de Queries

**Buscar padr√µes inseguros**:

```bash
# Buscar concatena√ß√£o de strings em queries
grep -r "SELECT.*\${" lambda/
grep -r "INSERT.*\${" lambda/
grep -r "UPDATE.*\${" lambda/
grep -r "DELETE.*\${" lambda/
```

### Padr√£o Correto

**Arquivo**: `lambda/shared/database.ts`

```typescript
import { Pool } from 'pg';

const pool = new Pool({
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  ssl: { rejectUnauthorized: false }
});

// ‚úÖ CORRETO: Usar prepared statements
export async function getTenantById(tenantId: string) {
  const query = 'SELECT * FROM tenants WHERE id = $1';
  const result = await pool.query(query, [tenantId]);
  return result.rows[0];
}

// ‚úÖ CORRETO: M√∫ltiplos par√¢metros
export async function searchTenants(search: string, status: string) {
  const query = `
    SELECT * FROM tenants 
    WHERE name ILIKE $1 
    AND status = $2
    ORDER BY created_at DESC
  `;
  const result = await pool.query(query, [`%${search}%`, status]);
  return result.rows;
}

// ‚ùå INCORRETO: Concatena√ß√£o de strings
export async function getTenantByIdUnsafe(tenantId: string) {
  const query = `SELECT * FROM tenants WHERE id = '${tenantId}'`;
  const result = await pool.query(query);
  return result.rows[0];
}
```

### Valida√ß√£o de Input

```typescript
import { z } from 'zod';

const TenantIdSchema = z.string().uuid();
const SearchSchema = z.string().max(100);
const StatusSchema = z.enum(['active', 'inactive', 'suspended']);

export async function searchTenantsValidated(
  search: string,
  status: string
) {
  // Validar inputs
  const validatedSearch = SearchSchema.parse(search);
  const validatedStatus = StatusSchema.parse(status);

  // Query segura
  const query = `
    SELECT * FROM tenants 
    WHERE name ILIKE $1 
    AND status = $2
  `;
  
  const result = await pool.query(query, [
    `%${validatedSearch}%`,
    validatedStatus
  ]);
  
  return result.rows;
}
```

---

## 4. Implementar Valida√ß√£o de Tamanho de Input

### Severidade: üü° M√âDIA

**Arquivo**: `lambda/shared/input-validator.ts`

```typescript
import { z } from 'zod';

// Schemas de valida√ß√£o
export const Schemas = {
  uuid: z.string().uuid(),
  email: z.string().email().max(255),
  name: z.string().min(1).max(255),
  search: z.string().max(100),
  description: z.string().max(1000),
  limit: z.number().int().min(1).max(100).default(50),
  offset: z.number().int().min(0).default(0),
  status: z.enum(['active', 'inactive', 'suspended', 'all']),
  period: z.enum(['7d', '30d', '90d']),
  commandType: z.enum(['REPROCESS_QUEUE', 'RESET_TOKEN', 'RESTART_AGENT', 'HEALTH_CHECK'])
};

// Validar query parameters
export function validateQueryParams<T>(
  params: Record<string, any>,
  schema: z.ZodSchema<T>
): T {
  try {
    return schema.parse(params);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new ValidationError('Invalid query parameters', error.errors);
    }
    throw error;
  }
}

// Validar body
export function validateBody<T>(
  body: string | null,
  schema: z.ZodSchema<T>
): T {
  if (!body) {
    throw new ValidationError('Request body is required');
  }

  try {
    const parsed = JSON.parse(body);
    return schema.parse(parsed);
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new ValidationError('Invalid JSON in request body');
    }
    if (error instanceof z.ZodError) {
      throw new ValidationError('Invalid request body', error.errors);
    }
    throw error;
  }
}

export class ValidationError extends Error {
  constructor(
    message: string,
    public details?: any
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}
```

### Usar nos Handlers

```typescript
import { validateQueryParams, Schemas } from '../shared/input-validator';

const QueryParamsSchema = z.object({
  search: Schemas.search.optional(),
  status: Schemas.status.optional(),
  limit: Schemas.limit,
  offset: Schemas.offset
});

export const handler = async (event: APIGatewayProxyEvent) => {
  try {
    // Validar query parameters
    const params = validateQueryParams(
      event.queryStringParameters || {},
      QueryParamsSchema
    );

    // Usar params validados
    const results = await searchTenants(params);
    
    return successResponse(results);
  } catch (error) {
    if (error instanceof ValidationError) {
      return errorResponse(400, error.message);
    }
    return errorResponse(500, 'Internal server error');
  }
};
```

---

## 5. Configurar Content Security Policy

### Severidade: üü° M√âDIA

**Arquivo**: `frontend/next.config.js`

```javascript
const securityHeaders = [
  {
    key: 'X-DNS-Prefetch-Control',
    value: 'on'
  },
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload'
  },
  {
    key: 'X-Frame-Options',
    value: 'SAMEORIGIN'
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff'
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block'
  },
  {
    key: 'Referrer-Policy',
    value: 'strict-origin-when-cross-origin'
  },
  {
    key: 'Permissions-Policy',
    value: 'camera=(), microphone=(), geolocation=()'
  },
  {
    key: 'Content-Security-Policy',
    value: [
      "default-src 'self'",
      "script-src 'self' 'unsafe-eval' 'unsafe-inline'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self' data:",
      "connect-src 'self' https://api.alquimista.ai https://cognito-idp.us-east-1.amazonaws.com",
      "frame-ancestors 'none'",
      "base-uri 'self'",
      "form-action 'self'"
    ].join('; ')
  }
];

module.exports = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: securityHeaders
      }
    ];
  }
};
```

---

## 6. Implementar Logging de Seguran√ßa

### Severidade: üü° M√âDIA

**Arquivo**: `lambda/shared/security-logger.ts`

```typescript
import { logger } from './logger';

export interface SecurityEvent {
  type: 'unauthorized_access' | 'rate_limit_exceeded' | 'invalid_token' | 'suspicious_activity';
  userId?: string;
  tenantId?: string;
  ip: string;
  userAgent?: string;
  resource: string;
  details?: any;
}

export function logSecurityEvent(event: SecurityEvent): void {
  logger.warn('Security event', {
    ...event,
    timestamp: new Date().toISOString(),
    severity: 'security'
  });

  // Enviar para sistema de alertas se cr√≠tico
  if (event.type === 'unauthorized_access') {
    // TODO: Integrar com SNS/CloudWatch Alarms
  }
}

export function logUnauthorizedAccess(
  userId: string | undefined,
  tenantId: string | undefined,
  resource: string,
  ip: string
): void {
  logSecurityEvent({
    type: 'unauthorized_access',
    userId,
    tenantId,
    ip,
    resource
  });
}

export function logRateLimitExceeded(
  key: string,
  type: string,
  ip: string
): void {
  logSecurityEvent({
    type: 'rate_limit_exceeded',
    ip,
    resource: key,
    details: { limitType: type }
  });
}
```

---

## 7. Checklist de Implementa√ß√£o

### Cr√≠tico (Antes de Produ√ß√£o)
- [ ] Rate limiting implementado
- [ ] Headers de seguran√ßa configurados
- [ ] Prepared statements auditados
- [ ] OWASP ZAP scan executado

### Alto (Pr√≥xima Sprint)
- [ ] Valida√ß√£o de tamanho de input
- [ ] Content Security Policy configurado
- [ ] Logging de seguran√ßa implementado
- [ ] Testes automatizados passando

### M√©dio (Pr√≥ximo M√™s)
- [ ] WAF rules customizadas
- [ ] Penetration testing profissional
- [ ] Security audit completo
- [ ] Documenta√ß√£o de seguran√ßa atualizada

---

## 8. Testes Ap√≥s Corre√ß√µes

```bash
# Executar testes de seguran√ßa
npm run test:security

# Executar OWASP ZAP scan
.\tests\security\owasp-zap-scan.ps1 -Target "https://api-dev.alquimista.ai"

# Verificar rate limiting
.\tests\security\test-rate-limiting.ps1

# Auditar queries SQL
.\tests\security\audit-sql-queries.ps1
```

---

## Refer√™ncias

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [AWS Security Best Practices](https://aws.amazon.com/security/best-practices/)
- [Node.js Security Checklist](https://github.com/goldbergyoni/nodebestpractices#6-security-best-practices)
